<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Маршрут проектирования</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <h2>Маршрут проектирования с eshell</h2>
      <hr>
      <p>
         <b>eshell</b> разработан для применения на этапе разработки и отладки RTL, а также для проведения логического синтеза / DFT / ATPG.
         <b>eshell</b> содержит библиотеку синтезируемых моделей с открытым исходным кодом - EHL (Eshell Hardware Library).
      </p>
      <h3>Запуск</h3>
      <p>При запуске, <b>eshell</b> позволяет указать следующие параметры работы:</p>
      <table summary="bugs" cellpadding="4" width="0%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Опция</th>
               <th>Аргумент</th>
               <th>Описание</th>
               <th>Комментарий</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>-nolog</td>  <td></td><td>запуск программы без генерации лога</td> <td></td> </tr>
            <tr> <td>-quiet</td>  <td></td><td>запуск программы без вывода в консоль</td> <td></td> </tr>
            <tr> <td>-noinit</td> <td></td><td>запуск программы без исполнения autosetup.tcl, расположенного в рабочем каталоге</td> <td></td> </tr>
            <tr> <td>-tcl</td>    <td></td><td>запуск в режиме tcl</td> <td></td> </tr>
            <tr> <td>-nodb</td>   <td></td><td>запуск без сохранения скомпилированных файлов в базу на диске</td> <td></td> </tr>
            <tr> <td>-script</td> <td>filename</td> <td>запуск программы с исполнением указанного файла вместо файла по умолчанию - autosetup.tcl</td> <td></td> </tr>
            <tr> <td>-help</td>   <td></td> <td>вызов справки и выход</td> <td></td> </tr>
            <tr> <td>-dir</td>    <td>directory</td> <td>запуск программы с указанием рабочей директории (вместо текущего каталога)</td> <td></td> </tr>
         </tbody>
      </table>

      <br></br>
      <p>
         После запуска программа исполняет файл autosetup.tcl, размещаемый в текущем каталоге (если нет опции <b>-noinit</b>, и не задается альтернативный скрипт с помощью <b>-script</b>).
         По окончании исполнения скрипта контроль переходит к пользователю (если не было команды <b>exit</b>).
      </p>
      <p>В процессе работы программа создает лог выполнения, располагаемый в рабочей директории и называемый workspace.log. Где workspace - имя проекта, задаваемое в программе с помощью команды <b>set_workspace WORKSPACE_NAME</b> (значение по умолчанию - eshell).</p>
      <p>Успешно скомпилированные модули размещаются в базу на диске. Имя базы workspace.edb.</p>
      <p>Запуск программы производится из текущего каталога, а сохранение лога и баз данных происходит в рабочую директорию (текущий каталог, либо каталог, указанный при запуске программы с помощью <b>-dir</b>).</p>

      <h3>Компиляция</h3>
      <p><b>eshell</b> позволяет скомпилировать 2 типа представлений дизайна: Liberty и Verilog.</p>
      <p>1. Компиляция библиотек Liberty происходит с помощью <b>read_lib</b>. Файлы сохраняются на диск в рабочей директории в workspace.ldb.</p>
      <p>2. Компиляция RTL описания происходит с помощью <b>read</b>. Файлы сохраняются на диск в рабочей директории в workspace.edb.</p>
      <p>Очистка базы данных для текущего workspace в рабочей директории выполняется с помощью <b>clear_db</b>.</p>

      <h3>Элаборация</h3>
      <p>Элаборация дизайна разбивается на несколько стадий, управляемых пользователем:</p>
      <p>1. Построение дизайна (<b>build</b>). Во время этой фазы выстраивается иерархия и проверяется целостность дизайна.
         Проводится набор простых оптимизаций (constant propagation, structural hashing, unloaded logic removal).
         На данном этапе в дизайне сохраняются все триггеры, защелки, иерархические модули, даже если они не подключены к выходам дизайна.
         Это позволяет применить SDC ограничения без ошибок, вызванных, например, специфичной конфигурацией дизайна.
      </p>

      <p>
         <b style="color: #FF0000">
            Замечение.
         </b>
         Для предварительной оценки характеристик дизайна в отсутствии части функциональных модулей может быть применен маршрут с применением black-box.
         Следует иметь в виду, что указанный маршрут предназначен только для проведения оценочных работ. Для активации маршрута следует выполнить <b>unset break_elab_on_unreferenced_instance</b>.
      </p>

      <p>2. Архитектурные оптимизации (<b>opt</b>).
         На данном этапе происходит выбор архитектуры макроблоков (сумматоров, компараторов, умножителей...) и применение к ним набора более сложных оптимизаций (resource sharing, rewrite...).
         Происходит удаление неиспользуемых триггеров, иерархических модулей.
         Данный этап направлен на удаление избыточной логики.
         Для активации алгоритмов, направленных на оптимизацию критических путей без увеличения аппаратных ресурсов рекомендуется перед <b>opt</b> выполнить <b>report_timing</b>.
      </p>
      <p>3. Оптимизация быстродействия (<b>opt -time</b>).
         Данный этап предназначен для сокращения задержек на критических путях в схеме. <b>eshell</b> последовательно оптимизирует наиболее критический путь в схеме применяя методы balancing, Shannon Decomposition, Observability Don't Care, SOP balancing, AND-OR balancing и другие.
      </p>
      <p>4. Technology Mapping (<b>techmap</b>).
	  На данном этапе происходит преобразование дизайна из логического представления в представление в базисе выбранной технологии.
<!--
	  This stage maps design into technology basis and estimates delays to determine critical paths.
	  Further optimizations made on this paths.
	  Usually timing optimizations cause area increase, so this step applied to critical path only, to maintain logic area at lower level (whenever possible).
-->
      </p>
<!-- <p>2. Архитектурные оптимизации (<b>opt</b>). На данном этапе происходит выбор архитектуры макроблоков (сумматоров, компараторов, умножителей...) и применение к ним набора более сложных оптимизаций (local optimizations, Shannon decomposition, delay balancing...). -->

      <h3>Рекомендуемый маршрут</h3>
      <p>
         Далее приведен базовый маршрут использования <b>eshell</b> для получения технологического netlist.
         Маршрут может незначительно варьироваться, например, отдельные операции могут быть пропущены или выполнены при отдельном запуске программы (например, компиляция RTL).
      </p>
<!--       <p>Also there are many ways to run sequence of commands, there is recommended sequence for better QoR:</p> -->
      <p>1. <b>read_lib</b> - компиляция технологических библиотек;</p>
      <p>2. <b>read</b> - компиляция RTL описания;</p>
      <p>3. <b>build</b> - элаборация дизайна;</p>
      <p>4. <b>read_sdc</b> - задание ограничений дизайна;</p>
      <p>5. <b>opt</b> - оптимизация дизайна.
<!--          Mapping made at this point and any SDC applied later in design flow will not impact architectural choices made at this point. -->
<!--          Mapping includes architecture choose for adders, multipliers and other operators that can be implemented with area/performance trade-off. -->
      </p>
      <p>6. <b>report_timing</b> - задание параметров временного графа;</p>
      <p>7. <b>opt -recursive</b> - оптимизация с учетом времени распространения сигналов;</p>
      <p>8. <b>techmap</b> - маппинг в базис технологической библиотеки;</p>
      <p>9. <b>write</b> - выгрузка netlist.</p>
      <br>

      <h3>Алгоритм оптимизации задержек</h3>
<!--
Перед проведением технологического маппинга проводится оптимизация схемы.
Вначале проводятся оптимизации приводящие к уменьшению размера схемы.
Далее проводятся оптимизации уменьшающие длину критического пути без увеличения площадисхемы.*
* площадь может незначительно увеличиваться в некоторых случаях, таких как маппинг XOR или оптимизация цепочек AND (OR) вентилей, когда оптимизация приводит к частичному дублированию функции.

После завершения указанных оптимизаций может запускаться алгоритм минимизации задержек критических путей.
Для этого критические пути аннотируются оценочными задержками, полученными из библиотеки. Выбирается задержка элементов AND2, INV, XOR. Их задержки аннотируют дизайн и сравниваются с ограничениями.
Те части схемы, которые не укладываются в требования по тактовой частоте оптимизируются.
При этом происходит увеличение площади дизайна. Основным механизмом оптимизации является декомпозици Шэннона или Generalized Select Transform.

После завершения указанного алгоритма производится технологический маппинг и расчет реальных задержек.
По итогам расчета может проводиться оптимизация путей, которые не укладываются в требуемые ограничения.
-->
      <p>
         В процессе элаборации происходит построение графа схемы с минимизацией ресурсов с сохранением триггеров и модулей для последующего применения SDC.
         При последующей оптимизации также происходит минимизация схемы (в отдельных случаях возможен незначительный прирост количества вентилей - <b>gates</b> в терминах схемы) с удалением избыточных ресурсов всех видов (включая триггеры).
         Первая после <b>report_timing</b> оптимизация имеет информацию о времени прихода сигналов и применяет дополнительные оптимизации, такие как балансировка сигналов внутри деревьев AND, OR, XOR вентилей.
         Такие оптимизации также не приводят к увеличению аппаратных ресурсов.
      </p>
      <p>
         Оптимизация критических путей происходит с увеличением количества аппаратных ресурсов по следующему принципу.
         Иначально применяется балансировка внутри AND, OR, XOR деревьев с fanout > 1 (это приводит к появлению дополнительной логики).
      </p>
      <p>Например, выражение <b>(A & B) & C</b> для позднее приходящего <b>A</b> может быть переписано как <b>(B & C) & A</b>.
         При этом, если <b>A & B</b> имело fanout > 1, то вентиль сохранится, и количество вентилей вырастет на 1.
      </p>
      <p>
	     На следующем этапе происходит оптимизация AND-OR деревьев логики, наиболее часто встречающихся в логических схемах, производных от сумматоров.
      </p>
      <p>
	     Далее оптимизируются задержки в схемах вида <b>A & ((B&C) | (D&E)))</b>, приводимых к виду <b>((B&C&A) | (D&E&A)))</b>.
      </p>
<!--      <p>
         После применения балансировки происходит декомпозиция Шеннона. Она приводит к увеличению площади примерно на N вентилей для сокращения задержки на 2 для выбранной группы вентилей.
      </p>-->
      <p></p>

   </body>
</html>
